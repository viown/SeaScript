#include <string.h>
#include <stdlib.h>
#include "./parser.h"
#include "./lex.h"

/*
	the lexer tokens generated by lex.h is passed to the parser, which will piece together the tokens by identifying variables, function calls, etc.
	the output result is passed to compiler.c which will generate the vm bytecode.
*/

/* check whether current identifier leads to a function call */
inline bool is_function_call(Token* current_token) {
	return strcmp(NEXT_TOKEN(current_token).value, FUNC_OPEN) == 0 && !(strcmp(PREVIOUS_TOKEN(current_token).value, "function") == 0);
}

/* check whether current identifier is a function definition */
inline bool is_function_definition(Token* current_token) {
	return strcmp(NEXT_TOKEN(current_token).value, FUNC_OPEN) == 0 && (strcmp(PREVIOUS_TOKEN(current_token).value, "function") == 0);
}

bool is_variable_declaration(Token* current_token) {
	return strcmp(PREVIOUS_TOKEN(current_token).value, "global") == 0 || strcmp(PREVIOUS_TOKEN(current_token).value, "local") == 0;
}

/* this is what I expect to be passed in: func(test(23)) */
/*                                             ^^^^^^^^  */
State parse_argument(Token* token) {
	State state;
	if (is_function_call(&token[0])) {
		/* todo, this is gonna involve using recursion until a literal is found */
	} else if (token->token == LITERAL) {
		ss_Literal literal;
		literal.value = atof(token->value);
		state.state = &literal;
		state.type = s_LITERAL;
	} else {
		state.state = NULL;
		state.type = s_NULLTYPE;
	}
	return state;
}

/* skips to end of statement */
void skip_to_end(Token** ptoken) {
	while (strcmp((*ptoken)->value, EOS) != 0) {
		(*ptoken)++;
	}
}

/* reads the tokens until an ';' is encountered */
State* parse_statement(Token* token) {
	State* states = malloc(255 * sizeof(State));
	int used = 0;
	while (strcmp(token->value, EOS) != 0) {
		if (token->token == IDENTIFIER) {
			if (is_function_call(token)) {
				/* todo */
			} else {
				State state;
				ss_Identifier identifier;
				strcpy(identifier.identifier, token->value);
				state.state = &identifier;
				state.type = s_IDENTIFIER;
				states[used++] = state;
			}
		} else if (token->token == OPERATOR) {
			if (IS_MATH_OP(token->value[0])) {
				State state;
				ss_Operator op;
				Operator math_operator = token->value[0];
				op.type = MATH;
				op.op = &math_operator;
				state.state = &op;
				state.type = s_OPERATOR;
				states[used++] = state;
			}
		}
		token++;
	}
	return states;
}

State* parse(lex_Object object) {
	Token* current_token = object.tokens;
	Token* end = &current_token[object.token_used];
	State* states = malloc(1000 * sizeof(State)); /* temporary */
	int used = 0;
	while (current_token != end) {
		if (current_token->token == KEYWORD) {
			if (is_variable_declaration(current_token + 1)) {
				Token* variable_name = ++current_token;
				++current_token; /* skip assignment operator */
				Token* value = ++current_token; /* pointer to first token */
				State* var_state = parse_statement(value);
				ss_Variable variable;
				strcpy(variable.variable_name, variable_name->value);
				variable.states = var_state;

				State variable_state;
				variable_state.state = &variable;
				variable_state.type = s_VARIABLE;
				states[used++] = variable_state;
				ss_Variable v = *(ss_Variable*)states[0].state;
				/*
				ss_Identifier x = *(ss_Identifier*)var_state[0].state;
				printf("Type: %d\n", var_state[0].type);
				printf("L: %s", x.identifier);*/
				skip_to_end(&value);
			}
		}
		current_token++;
	}
	return states;
}

