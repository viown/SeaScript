#include <string.h>
#include <stdlib.h>
#include "./parser.h"
#include "./lex.h"

/*
	the lexer tokens generated by lex.h is passed to the parser, which will piece together the tokens by identifying variables, function calls, etc.
	the output result is passed to compiler.c which will generate the vm bytecode.
*/

/* check whether current identifier leads to a function call */
static inline bool is_function_call(Token* current_token) {
	return strcmp(NEXT_TOKEN(current_token).value, FUNC_OPEN) == 0 && !(strcmp(PREVIOUS_TOKEN(current_token).value, "function") == 0);
}

/* check whether current identifier is a function definition */
static inline bool is_function_definition(Token* current_token) {
	return strcmp(NEXT_TOKEN(current_token).value, FUNC_OPEN) == 0 && (strcmp(PREVIOUS_TOKEN(current_token).value, "function") == 0);
}

static inline bool is_variable_declaration(Token* current_token) {
	return strcmp(PREVIOUS_TOKEN(current_token).value, "global") == 0 || strcmp(PREVIOUS_TOKEN(current_token).value, "local") == 0;
}

/* this is what I expect to be passed in: func(test(23)) */
/*                                             ^^^^^^^^  */
State parse_argument(Token* token) {
	State state;
	if (is_function_call(&token[0])) {
		/* todo, this is gonna involve using recursion until a literal is found */
	} else if (token->token == LITERAL) {
		ss_Literal literal;
		literal.value = atof(token->value);
		state.state = &literal;
		state.type = s_LITERAL;
	} else if (token->token == IDENTIFIER) {
		ss_Identifier identifier;
		strcpy(identifier.identifier, token->value);
		state.state = &identifier;
		state.type = s_IDENTIFIER;
	}
	return state;
}

/* skips to end of statement */
void skip_to_end(Token** ptoken) {
	while (strcmp((*ptoken)->value, EOS) != 0) {
		(*ptoken)++;
	}
}

/* reads the tokens until an ';' is encountered */
State* parse_statement(Token* token) {
	State* states = malloc(255 * sizeof(State));
	int used = 0;
	while (strcmp(token->value, EOS) != 0) {
		if (token->token == IDENTIFIER) {
			if (is_function_call(token)) {
				/* todo */
			} else {
				State state;
				ss_Identifier identifier;
				strcpy(identifier.identifier, token->value);
				state.state = &identifier;
				state.type = s_IDENTIFIER;
				states[used++] = state;
			}
		} else if (token->token == OPERATOR) {
			if (IS_MATH_OP(token->value[0])) {
				State state;
				ss_Operator op;
				Operator math_operator = token->value[0];
				op.type = MATH;
				op.op = &math_operator;
				state.state = &op;
				state.type = s_OPERATOR;
				states[used++] = state;
			}
		}
		token++;
	}
	return states;
}

ss_Variable* create_variable(char* var_name, State* var_states) {
	ss_Variable* variable = malloc(sizeof(ss_Variable));
	strcpy(variable->variable_name, var_name);
	variable->states = var_states;
	return variable;
}

ParseObject parse(lex_Object object) {
	Token* current_token = object.tokens;
	Token* end = &current_token[object.token_used];
	ParseObject parse_obj;
	State* states = malloc(1000 * sizeof(State)); /* temporary */
	int length = 0;
	while (current_token != end) {
		if (current_token->token == KEYWORD) {
			if (is_variable_declaration(current_token + 1)) {
				Token* variable_name = ++current_token;
				++current_token; /* skip assignment operator */
				Token* value = ++current_token; /* pointer to first token */
				State* var_state = parse_statement(value);
				ss_Variable* variable = create_variable(variable_name->value, var_state);

				State variable_state;
				variable_state.state = &(*variable);
				variable_state.type = s_VARIABLE;
				states[length++] = variable_state;
				skip_to_end(&current_token);
			}
		}
		current_token++;
	}
	parse_obj.begin = states;
	parse_obj.length = length;
	return parse_obj;
}

