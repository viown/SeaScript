# SeaScript Internals
This is something I wrote which I can use as a reference later on in the future, it documents how this language works internally. You're more than welcome to read this, although I believe your time could be better spent elsewhere.

# Introduction
This language is pretty simple, it does not have a standard library (yet) and only has two built-in functions:

 - print - Outputs a message onto the console
 - exit - Terminates the program with an exit code
 
It also provides math operators ( `+`, `-`, `*`, `/` ) and comparison operators ( `>`, `<`, `==`, `>=`, `<=`).
You can do the most basic string manipulation with the `+=` operator.

# Simple Program
Let's demonstrate a simple program in this language and the process SeaScript takes onto running it,

    global value = 100;
    global value2 = 50;
    global value3 = value + value2;
    
    print(value3); // -> 150

Upon running this program, the code will first go through the lexical analysis process which involves splitting the code into tokens representing a certain value such a keyword, identifier, operator, etc.
The following token stream is generated from the above code sample:

    <SPECIFIER='KEYWORD', VALUE='global'>
    <SPECIFIER='IDENTIFIER', VALUE='value'>
    <SPECIFIER='OPERATOR', VALUE='='>
    <SPECIFIER='LITERAL', VALUE='100'>
    <SPECIFIER='OPERATOR', VALUE=';'>
    <SPECIFIER='KEYWORD', VALUE='global'>
    <SPECIFIER='IDENTIFIER', VALUE='value2'>
    <SPECIFIER='OPERATOR', VALUE='='>
    <SPECIFIER='LITERAL', VALUE='50'>
    <SPECIFIER='OPERATOR', VALUE=';'>
    <SPECIFIER='KEYWORD', VALUE='global'>
    <SPECIFIER='IDENTIFIER', VALUE='value3'>
    <SPECIFIER='OPERATOR', VALUE='='>
    <SPECIFIER='IDENTIFIER', VALUE='value'>
    <SPECIFIER='OPERATOR', VALUE='+'>
    <SPECIFIER='IDENTIFIER', VALUE='value2'>
    <SPECIFIER='OPERATOR', VALUE=';'>
    <SPECIFIER='IDENTIFIER', VALUE='print'>
    <SPECIFIER='PUNCTUATOR', VALUE='('>
    <SPECIFIER='IDENTIFIER', VALUE='value3'>
    <SPECIFIER='PUNCTUATOR', VALUE=')'>
    <SPECIFIER='COMMENT', VALUE='// -> 150'>

Whitespace is ignored during the lexical analysis process as it's usually meaningless in the language.

This token stream is then passed on to the parser, the parser involves piecing together the tokens into something that makes sense such as a function call or a variable declaration.

The output generated by the parser is then passed onto the compiler, which will convert the output into bytecode which can be executed through the language's process virtual machine. The bytecode can also be preserved in a file so that you wouldn't need to re-compile the code every single time you want to run the code.

The bytecode is interpreted by the language's virtual machine.

# Arrays

An array can be defined like so,

    global nums = [10, 20, 30, 45];
You can index an element through the index operator like so, `nums[0]`, `nums[1]`, `nums[2...]`.
As of right now, you cannot iterate over an array, while that does sound like an important feature that each language should have, but this project isn't intended to be used in production (Use C++ like a normal person, why are you here?).

You can append an array through the `+=` operator, which can be done like so:

    nums += 30; // appends `30` to the end of the array.
You can also append multiple numbers at once,

    nums += [30, 50, 60]

# Functions
You can define your own function like so:

    function add(a, b) {
	    return a + b;
	}
However for one-liner functions, you can use lambdas:

    function add(a, b) = a + b;

This is the same thing as the code above.

# String

A string can be defined like so,

    global str = "Hello, world!";

This is a representation of a string, however internally this is just an array of ASCII characters, the same string can be defined like so:

    global str = [72, 101, 108, 108, 111, 44, 32, 119, 111, 114, 108, 100, 33, 0];
    
    print(str) // Hello, world!

The `0` at the end of the array is the NULL terminator. Which you can't reference in a string like so:

`"Hello\0 World!"` - won't work!

This wouldn't work for safety reasons, however strings do support escape sequences like `\n`, `\t` and a few others.

# Virtual Machine
SeaScript uses a process virtual machine I made called [seavm](https://github.com/viown/SeaScript/tree/master/src/seavm). Now I know what you're probably thinking, "Why would a typeless language use a VM?" And truth is, I didn't think things through when starting on this project. However using a VM still has its benefits such as being able to preserve the bytecode onto a file and execute it without having to lex, parse and re-compile the code every time you want to run it. (However you can still do that with barely any performance impacts.).

The VM's Instruction set is fairly small, not more than 19 instructions, but there is really no need to overcomplicate it any further. I'd list the instructions here but I change them frequently, so you can look at them here if you want: https://github.com/viown/SeaScript/blob/master/src/seavm/opcodes.h.


# Embedding C Functions

You can embed your own C functions and call them through SeaScript pretty easily, this is done by registering the function onto the virtual machine and your function can be executed through the `CALLC` instruction. However you'd have to build SeaScript yourself with the C functions to make them callable.
The function must follow this declaration:

    void embedded_c_function(Vm* vm)

This gives the function the ability to modify the vm's stack and globals. However when you push a value onto the stack, make sure it's heap allocated because the VM will attempt to free the memory at the program's termination.

If you allocated memory that wasn't pushed to the stack or as a global, you can free it at the program's termination through the `vm_on_terminate` function which may already be defined somewhere:

    void vm_on_terminate(Vm* vm) {
		free(memory);
	}

 

# Extra

When compiling SeaScript, the executable should be no larger than 200KBs (may vary depending on which C compiler you use.) making it great for embedded systems, however I'd never recommend using this. It's just my own personal project I made for fun.
